/**
 * ðŸ”´ LONGSANG ERROR REPORTER
 * Auto-reports errors to longsang-admin for auto-fix
 * Generated by auto-inject-error-reporter.cjs
 */

const ADMIN_URL = 'https://longsang-admin.vercel.app';
const APP_NAME = 'vungtau-dream-homes';

class ErrorReporter {
  private static instance: ErrorReporter;
  private errorQueue: any[] = [];
  private isProcessing = false;

  static getInstance() {
    if (!this.instance) {
      this.instance = new ErrorReporter();
    }
    return this.instance;
  }

  constructor() {
    this.setupGlobalHandlers();
    this.startQueueProcessor();
  }

  private setupGlobalHandlers() {
    // Catch unhandled errors
    if (typeof window !== 'undefined') {
      window.onerror = (message, source, lineno, colno, error) => {
        this.reportError({
          type: error?.name || 'Error',
          message: String(message),
          stack: error?.stack,
          file: source,
          line: lineno,
          column: colno,
        });
        return false;
      };

      // Catch unhandled promise rejections
      window.onunhandledrejection = (event) => {
        this.reportError({
          type: 'UnhandledPromiseRejection',
          message: event.reason?.message || String(event.reason),
          stack: event.reason?.stack,
        });
      };

      // Catch React errors
      const originalConsoleError = console.error;
      console.error = (...args) => {
        const message = args.map(a => String(a)).join(' ');
        if (message.includes('Error') || message.includes('error')) {
          this.reportError({
            type: 'ConsoleError',
            message: message.slice(0, 500),
          });
        }
        originalConsoleError.apply(console, args);
      };
    }
  }

  reportError(errorData: {
    type: string;
    message: string;
    stack?: string;
    file?: string;
    line?: number;
    column?: number;
  }) {
    // Extract file and line from stack if not provided
    let file = errorData.file;
    let line = errorData.line;
    
    if (!file && errorData.stack) {
      const stackMatch = errorData.stack.match(/at\s+.*?\((.*?):(\d+):(\d+)\)/);
      if (stackMatch) {
        file = stackMatch[1];
        line = parseInt(stackMatch[2]);
      }
    }

    this.errorQueue.push({
      app: APP_NAME,
      type: errorData.type,
      message: errorData.message,
      file: file || 'unknown',
      line: line || 0,
      stack: errorData.stack,
      timestamp: new Date().toISOString(),
      url: typeof window !== 'undefined' ? window.location.href : '',
      userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : '',
    });
  }

  private async startQueueProcessor() {
    setInterval(async () => {
      if (this.isProcessing || this.errorQueue.length === 0) return;
      
      this.isProcessing = true;
      const errors = [...this.errorQueue];
      this.errorQueue = [];

      try {
        for (const error of errors) {
          await fetch(`${ADMIN_URL}/api/errors/report`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(error),
          }).catch(() => {}); // Silent fail
        }
      } finally {
        this.isProcessing = false;
      }
    }, 5000); // Send every 5 seconds
  }

  // Manual error capture
  capture(error: Error, context?: Record<string, any>) {
    this.reportError({
      type: error.name,
      message: error.message,
      stack: error.stack,
      ...context,
    });
  }
}

// Initialize and export
export const errorReporter = ErrorReporter.getInstance();

// For manual capture: errorReporter.capture(new Error('test'))
export default errorReporter;
